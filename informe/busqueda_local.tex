\section{Heurística de Búsqueda Local}

\subsection{Algoritmo}

Antes de explicar nuestro algoritmo, comenzemos definiendo que es una heurística de búsqueda local. Para cada solución factible $s \in S$, se define $N(s)$ como el conjunto de soluciones vecinas de $s$. Un procedimiento de búsqueda local toma una solución inicial $s$ e iterativamente la mejora reemplazándola por otra solución mejor del conjunto $N(s)$, hasta llegar a un optimo local. El algoritmo se puede ver con el siguiente pseudocodigo:

\begin{algorithmic}
\Procedure{localSearch}{G}
\State{s $\gets$ getInitialSolution(G)}
\State{bool localSolution $\gets$ true}
\While{localSolution}
	\State{$localSolution \gets false$}
	\ForAll{$\hat{s} \in N(s)$}
		\If{$|\hat{s}| < |s|$}
			\State{$s \gets \hat{s}$}
			\State{$localSolution \gets true$}
			\State{break}
		\EndIf
	\EndFor
\EndWhile
\EndProcedure
\end{algorithmic}

\hspace{1px}

En primer lugar hay que pensar que algoritmo utilizar en la función $getInitialSolution(G)$. Para esto, utilizamos la heurística constructiva golosa con score del paso anterior. Sin embargo también podemos utilizar la que se basa en un heap o se puede modificar backtracking para que tome la primera solución que encuentra.

Luego, debemos identificar como construiremos las diferentes $s \in N(s)$, es decir, como construiremos la función que nos devuelve los vecinos de una solución parcial $N(S)$. Para ello, seguiremos el siguiente procedimiento:

\begin{enumerate}
\item Tomamos un nodo del conjunto solución actual y lo quitamos.
\item Tomamos todos los nodos adyacentes a ese nodo, y los agregamos al conjunto solución si no existe otro nodo que lo pueda alcanzar. De esta manera mantenemos la independencia.
\item Si no agregamos a ningún nodo adyacente, al quitar el nodo ya no tenemos un cubrimiento, por lo que lo descartamos.
\end{enumerate}

\subsection{Complejidad}

En una iteración, nuestro algoritmo a lo sumo toma cada nodo del cubrimiento. Por lo tanto, en el peor caso una iteración tiene orden \order{n \times m^2}. Esto se debe a que se deben checkear todos los nodos adyacentes del que saque, y luego se debe verificar si ese nodo adicional tiene algun nodo adyacente perteneciente al cubrimiento. 
\textbf{NOTA: Puedo reemplazar m por el máximo grado en el grafo.}