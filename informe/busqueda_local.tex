\section{Heurística de Búsqueda Local}

\subsection{Algoritmo}

Antes de explicar nuestro algoritmo, comenzemos definiendo que es una heurística de búsqueda local. Para cada solución factible $s \in S$, se define $N(s)$ como el conjunto de soluciones vecinas de $s$. Un procedimiento de búsqueda local toma una solución inicial $s$ e iterativamente la mejora reemplazándola por otra solución mejor del conjunto $N(s)$, hasta llegar a un optimo local. El algoritmo se puede ver con el siguiente pseudocodigo:

\begin{algorithmic}
\Procedure{localSearch}{G}
\State{s $\gets$ getInitialSolution(G)}
\State{bool localSolution $\gets$ true}
\While{localSolution}
	\State{$localSolution \gets false$}
	\ForAll{$\hat{s} \in N(s)$}
		\If{$|\hat{s}| < |s|$}
			\State{$s \gets \hat{s}$}
			\State{$localSolution \gets true$}
			\State{break}
		\EndIf
	\EndFor
\EndWhile
\EndProcedure
\end{algorithmic}

\hspace{1px}

En primer lugar hay que pensar que algoritmo utilizar en la función $getInitialSolution(G)$. Para esto, utilizamos la heurística constructiva golosa con score del paso anterior. Sin embargo también podemos utilizar la que se basa en un heap o se puede modificar backtracking para que tome la primera solución que encuentra.

Luego, debemos identificar como construiremos las diferentes $s \in N(s)$, es decir, como construiremos la función que nos devuelve los vecinos de una solución parcial $N(S)$.

\subsection{Vecindades}

Para este algoritmo, utilizaremos los siguientes dos criterios para definir la vecindad de una solución $s$:

\begin{enumerate}
\item Primera vecindad:
Para la primera vecindad simplemente tomamos un vértice que actualmente no pertenece a la solución local. Luego, quitamos todos sus vértices adyacentes y verificamos si tenemos una solución con menor cardinal.
\item Segunda vecindad:
Para este criterio, lo que hacemos es buscar dos nodos que no pertenecen a la solución local. Los agregamos, quitamos sus nodos adyacentes, y verificamos si el nuevo conjunto es un cubrimiento de menor cardinal.
\end{enumerate}

\subsection{Complejidad}

En una iteración, nuestro algoritmo a lo sumo toma cada nodo del cubrimiento. Por lo tanto, en el peor caso una iteración tiene orden \order{n \times m^2}. Esto se debe a que se deben checkear todos los nodos adyacentes del que saque, y luego se debe verificar si ese nodo adicional tiene algún nodo adyacente perteneciente al cubrimiento. 

\textbf{NOTA: Puedo reemplazar m por el máximo grado en el grafo.}

\textbf{Falta análisis de complejidad para el segundo criterio de vecindad.}

